import cv2
import math
import numpy as np

import sys
sys.path.append("lane_detection_utils/")
from absolute_speed_3 import absolute_speed_estimation
from scanning_region import scan_region
from road_sampling import brightness_sampling
from outlayer_removal_and_average_brightness import outlayer_removal_and_average_brightness_computation
from average_delta_across_marking import average_delta
from determination_of_parallelism_with_previously_tracked_lanes import determination_of_parallelism
from lane_signature_detection import lane_signature_detection
from eliminate_duplicate_road_marks import eliminate_duplicate_road_marks
from merging_all_road_marks import merging_all_road_marks
from filtering import filtering
from long_term_average import long_term_average_of_lanes


####################################################################################################################################################################################################
# LANE DETECTION
#
# The python script below delivers lane detection based on the LSD (line segment detector) algorithm and its application to the detection of white road markings. The main idea is to sample the
# brightness of the pixels around the borders of the potential white road mark and extract specific charcateristics/features of the pixels arranged around. Based on these features a particular
# signature for a white road mark is detected. Based on the detected white road marks a line representing the lane is determined by finding the line that crosses all the detected white marks on each
# side (either left or right).
#
# The script is divided into sections which we will describe below:
#
# I) IMAGE READING
# The image is read in grayscle for processing and in color for visualization. We take the bottom portion of the image (subframe) for LSD processing since this is the area
# of interest to find white markings.
#
# II) LSD ALGORITHM
# We invoke the LSD algorithm to detect all straight line segments detected on the image. We redraw the detected lines in the image to emphasize the edges for subsequent processing.
#
# III) SCANNING OF THE IMAGE AND DETECTION OF ROAD MARK SIGNATURE
# This section is subdivided as follows:
#     a) Scan region and generate line segments
#     We use a rectangular window that moves over the image subframe and we collect all the line segments inside the region for further analysis.
#
#     b) From all the lines collected in a) we find the two lines that are closest to the top of the scanning region. These two lines will be used to find the signature.
#
#     c) For the two-top lines found in b) we sample 5 pixels around the two lines. We use horizontal lines that cross the two-top lines and along each horizontal line we sample two pixels
#     to the left of the left-line, two pixels to the right of the right-line and we sample one pixel that is in the middle between the two top-lines (the right-line and the left-line). We
#     extract aggregated statistics based on the samples obtained. These statistics provide the ability to determine the existence of the white road mark signature if it exists.
#
# IV) ELIMINATION OF WHITE ROAD MARK DUPLICATES
# Since the scanning region moves by steps it is possible that a white road marking could be captured more than once by two different positions of the scanning region. Here we eliminate duplicate
# detections of the same white road marking.
#
# V) MERGING ALL WHITE ROAD MARKS PREVIOUSLY DETECTED AND GENERATION OF TWO LANES
# Two o more white road markings detected over the left side of the ego-vehicle are used to determine the line that crosses all of them. This line becomes representative of the Lane defined by
# these white road markings. Similarly the same processing is performed over the right side of the ego-vehicle.
#
# VI) FILTERING WHITE ROAD MARKS TO REMOVE FALSE DETECTIONS AND CORRECTION OF THE TWO LANES
# If we compare the Lane that has been generated by white road marks in the current frame with the Lane that has been obatined in previous frames and we observe a significant deviation in terms of angle
# and horizontal separation we deem the Lane as a false detection and we assign as the current Lane the Lane that was detected on the previous image frame.
#
# VII) RECORDING OF CURRENTLY DETECTED LANES
# We keep a record of the two Lanes detected in the current frame so that we can use them for comparison/validation of future detections.
#
# VIII) GENERATION OF LONG TERM AVERAGE OF THE DETECTED LANES
# We generate a long term average of Lanes detected over the last 6 frames in order to provide stability to the detection and dampen transients.
#
# IX) DISPLAY
# We display the image emphasizing the area of the road with the white markings. This causes an aspect ration distortion overall, however the details of the detection are clearly visible.
#
#
####################################################################################################################################################################################################


##################### INITIALIZATION OF VARIABLES ###########################

count_lanes_previous=0
mux_lane_vec_previous=np.zeros(80)
muy_lane_vec_previous=np.zeros(80)
base_ptx_lane_vec_previous=np.zeros(80)
base_pty_lane_vec_previous=np.zeros(80)

count_lanes_previous2=0
mux_lane_vec_previous2=np.zeros(80)
muy_lane_vec_previous2=np.zeros(80)
base_ptx_lane_vec_previous2=np.zeros(80)
base_pty_lane_vec_previous2=np.zeros(80)

count_lanes_aggregated=0
mux_lane_vec_aggregated=np.zeros(80)
muy_lane_vec_aggregated=np.zeros(80)
base_ptx_lane_vec_aggregated=np.zeros(80)
base_pty_lane_vec_aggregated=np.zeros(80)

count_lanes_average_vec=0
mux_lane_vec_average=np.zeros(4000)
muy_lane_vec_average=np.zeros(4000)
base_ptx_lane_vec_average=np.zeros(4000)
base_pty_lane_vec_average=np.zeros(4000)

count_lanes_average_vec2=0
mux_lane_vec_average2=np.zeros(4000)
muy_lane_vec_average2=np.zeros(4000)
base_ptx_lane_vec_average2=np.zeros(4000)
base_pty_lane_vec_average2=np.zeros(4000)

count_lane_group1=0
count_lane_group2=0

white_mark_hit=0
count_road_nomark=0
capture_frameindex_for_speed=0
frameindex_for_speed_previous=0
frameindex_for_speed=0
count_scanned_lines_reverse_for_speed_previous=0
count_scanned_lines_reverse_for_speed=0
count_scanned_lines_for_speed_previous=0
count_scanned_lines_for_speed=0


white_mark_hit_1=0
count_road_nomark_1=0
capture_frameindex_for_speed_1=0
frameindex_for_speed_previous_1=0
frameindex_for_speed_1=0
count_scanned_lines_reverse_for_speed_previous_1=0
count_scanned_lines_reverse_for_speed_1=0
count_scanned_lines_for_speed_previous_1=0
count_scanned_lines_for_speed_1=0

base_ptx_lane_vec_final1=0
base_pty_lane_vec_final1=0
mux_lane_vec_final1=0
muy_lane_vec_final1=0

base_ptx_lane_vec_final2=0
base_pty_lane_vec_final2=0
mux_lane_vec_final2=0
muy_lane_vec_final2=0

mux_lane_vec_final1_previous=0
muy_lane_vec_final1_previous=0
base_ptx_lane_vec_final1_previous=0
base_pty_lane_vec_final1_previous=0

mux_lane_vec_final2_previous=0
muy_lane_vec_final2_previous=0
base_ptx_lane_vec_final2_previous=0
base_pty_lane_vec_final2_previous=0

x1_lane_group1=0
x1_lane_group2=0


initial_frame_was_processed_flag=0

first_reading_available_flag=0

parmanent_positioning=0

offset=0

offset_adjustment=0
offset_adjustment_1=0
count_marks_detected_for_adjustment=0
count_marks_detected_for_adjustment_b=0
count_marks_detected_for_adjustment_c=0
count_marks_detected_for_adjustment_1=0
count_marks_detected_for_adjustment_b_1=0
count_marks_detected_for_adjustment_c_1=0
offset_adjustment_acc=0
offset_adjustment_acc_b=0
offset_adjustment_acc_c=0
offset_adjustment_acc_1=0
offset_adjustment_acc_b_1=0
offset_adjustment_acc_c_1=0
count_adjustments=0
count_adjustments_b=0
count_adjustments_c=0
count_adjustments_1=0
count_adjustments_b_1=0
count_adjustments_c_1=0
exclude=0
exclude_b=0
exclude_c=0
exclude_1=0
exclude_b_1=0
exclude_c_1=0
range_adjustment_left=0
range_adjustment_right=0
range_adjustment_left_1=0
range_adjustment_right_1=0

Left_lane_available_display=0
Right_lane_available_display=0


########### CONFIGURABLE PARAMETERS #################

#inital and end points for the scanning in the x-direction within the image subframe, and step of the scanning
scan_x_ini=900
scan_x_end=1900
scan_x_step=50

#inital and end points for the scanning in the y-direction within the image subframe, and step of the scanning
scan_y_ini=110 #250 #200
scan_y_end=190 #330
scan_y_step=20

#size of the rectangular window used for the scanning
scanning_window_width=200
scanning_window_lenght=220

#threshold for brightness ratio between white road mark and pavement
brightness_ratio_threshold = 1.5

#tolerance for Lane deviation from previously detected Lanes
horizontal_tolerance = 70

#Restrict the area for lane detection. Left marging and right marging are the limits of this area
Left_marging_detection = 900
Right_margin_detection = 1900

#Long term average window size
average_window = 2


########### BEGINNING OF LANE DETECTION ################

for image_number in range(2700,2801):


    ######## IMAGE READING ########

    #Reading of Image Frame
    image_name='tests/GH_frames/'+str(image_number)+'.jpg'

    img = cv2.imread(image_name,cv2.IMREAD_GRAYSCALE) #image for processing algorithm
    img3 = cv2.imread(image_name)                     #image for visualization of results (in color)
    #img2=img[800:1400,0:2704]			      #image subframe that is closer to the bottom part of the frame where markings are more visible.
    #img4 = img3[800:1400,0:2704]                     #image subframe for visualization of results (in color)
    img2=img[940:1240,0:2704]			      #image subframe that is closer to the bottom part of the frame where markings are more visible.
    img4 = img3[940:1240,0:2704]                     #image subframe for visualization of results (in color)

    #cv2.namedWindow('img',cv2.WINDOW_NORMAL)
    #cv2.imshow('img',img2 )
    #cv2.waitKey(0)

    H, W =img.shape
    h1, w1= img2.shape



    count_lanes=0

    #Initialization on every frame
    mux_lane_vec=np.zeros(80)
    muy_lane_vec=np.zeros(80)
    base_ptx_lane_vec=np.zeros(80)
    base_pty_lane_vec=np.zeros(80)
    angle_lanes=np.zeros(80)





    img6 = img4.copy()



    ######## ABSOLUTE SPEED DETERMINATION ########

    muy_lane_vec_final2_speed_permanent_34=-0.5199735932802914
    mux_lane_vec_final2_speed_permanent_34=0.8541686919536207
    base_ptx_lane_vec_final2_speed_permanent_34=1193.0
    base_pty_lane_vec_final2_speed_permanent_34=94.5

    muy_lane_vec_final2_speed_permanent_36= -0.5070201265633938
    mux_lane_vec_final2_speed_permanent_36=  0.8619342151577695
    base_ptx_lane_vec_final2_speed_permanent_36=  1225.0
    base_pty_lane_vec_final2_speed_permanent_36=  138.0

    muy_lane_vec_final2_speed_permanent= (muy_lane_vec_final2_speed_permanent_34+muy_lane_vec_final2_speed_permanent_36)/2
    mux_lane_vec_final2_speed_permanent= (mux_lane_vec_final2_speed_permanent_34+mux_lane_vec_final2_speed_permanent_36)/2
    base_ptx_lane_vec_final2_speed_permanent= (base_ptx_lane_vec_final2_speed_permanent_34+base_ptx_lane_vec_final2_speed_permanent_36)/2
    base_pty_lane_vec_final2_speed_permanent= (base_pty_lane_vec_final2_speed_permanent_34+base_pty_lane_vec_final2_speed_permanent_36)/2


    #Speed on left track (group2)
    skip_speed_estimation=0
    speed_read_flag=0


    if skip_speed_estimation==0:

        speed,road_nomark,capture_frameindex_for_speed,frameindex_for_speed,white_mark_hit,speed_read_flag,count_scanned_lines_reverse_for_speed,count_scanned_lines_for_speed,offset,offset_at_end_of_mark,offset_at_middle_of_mark = absolute_speed_estimation(muy_lane_vec_final2_speed_permanent,mux_lane_vec_final2_speed_permanent,base_ptx_lane_vec_final2_speed_permanent,base_pty_lane_vec_final2_speed_permanent,h1,capture_frameindex_for_speed,frameindex_for_speed_previous,frameindex_for_speed,image_number,white_mark_hit,count_scanned_lines_reverse_for_speed_previous,count_scanned_lines_reverse_for_speed,count_scanned_lines_for_speed_previous,count_scanned_lines_for_speed,offset_adjustment,range_adjustment_left,range_adjustment_right,img6,img2)


        #Update Speed reading
        if speed_read_flag==1:
            speed_official=speed
            first_reading_available_flag=1

            #Lane information extraction
            Lintersection=(0.7*h1-base_pty_lane_vec_final2_speed_permanent)/muy_lane_vec_final2_speed_permanent
            x2_lane=base_ptx_lane_vec_final2_speed_permanent+Lintersection*mux_lane_vec_final2_speed_permanent+offset_adjustment
            pt1_x=x2_lane+offset
            pt1_y=0.7*h1

            Lintersection=(0.7*h1-(count_scanned_lines_for_speed-1)-base_pty_lane_vec_final2_speed_permanent)/muy_lane_vec_final2_speed_permanent
            x2_lane_scan=base_ptx_lane_vec_final2_speed_permanent+Lintersection*mux_lane_vec_final2_speed_permanent+offset_adjustment
            pt2_x=x2_lane_scan+offset_at_end_of_mark
            pt2_y=0.7*h1-(count_scanned_lines_for_speed-1)

            L_mark=((pt2_x-pt1_x)**2+(pt2_y-pt1_y)**2)**0.5
            mux_lane=(pt2_x-pt1_x)/L_mark
            muy_lane=(pt2_y-pt1_y)/L_mark

            if offset_at_middle_of_mark!=-1000:
                Lintersection=(0.7*h1-(20-1)-base_pty_lane_vec_final2_speed_permanent)/muy_lane_vec_final2_speed_permanent
                x2_lane_scan=base_ptx_lane_vec_final2_speed_permanent+Lintersection*mux_lane_vec_final2_speed_permanent+offset_adjustment
                pt2b_x=x2_lane_scan+offset_at_middle_of_mark
                pt2b_y=0.7*h1-(20-1)

                L_markb=((pt2_x-pt2b_x)**2+(pt2_y-pt2b_y)**2)**0.5
                mux_laneb=(pt2_x-pt2b_x)/L_markb
                muy_laneb=(pt2_y-pt2b_y)/L_markb

                pt2e_x=pt1_x+300*((mux_lane+mux_laneb)/2)
                pt2e_y=pt1_y+300*((muy_lane+muy_laneb)/2)

                pt2f_x=pt1_x-100*((mux_lane+mux_laneb)/2)
                pt2f_y=pt1_y-100*((muy_lane+muy_laneb)/2)

            else:
                pt2e_x=pt1_x+300*mux_lane
                pt2e_y=pt1_y+300*muy_lane

                pt2f_x=pt1_x-100*mux_lane
                pt2f_y=pt1_y-100*muy_lane

            Left_lane_available_display=1


        if road_nomark==1 and white_mark_hit==1:
            count_road_nomark=count_road_nomark+1


        # Detecting ending of white road mark (the marker is over the pavement)
        if count_road_nomark==5:
            white_mark_hit=0
            count_road_nomark=0
            capture_frameindex_for_speed=0
            frameindex_for_speed_previous=frameindex_for_speed
            count_scanned_lines_reverse_for_speed_previous=count_scanned_lines_reverse_for_speed
            count_scanned_lines_for_speed_previous=count_scanned_lines_for_speed
            prev_s=0

    #print("count_scanned_lines_reverse_for_speed_previous: ",count_scanned_lines_reverse_for_speed_previous)
    #print("count_scanned_lines_for_speed_prevous: ",count_scanned_lines_for_speed_previous)
    #input("previous")


    muy_lane_vec_final1_speed_permanent_34=-0.49613893835683387
    mux_lane_vec_final1_speed_permanent_34=-0.8682431421244593
    base_ptx_lane_vec_final1_speed_permanent_34=1468.0
    base_pty_lane_vec_final1_speed_permanent_34=55.0

    muy_lane_vec_final1_speed_permanent_36=-0.49613893835683387
    mux_lane_vec_final1_speed_permanent_36=-0.8682431421244593
    base_ptx_lane_vec_final1_speed_permanent_36=1631.0
    base_pty_lane_vec_final1_speed_permanent_36=192.0

    muy_lane_vec_final1_speed_permanent= (muy_lane_vec_final1_speed_permanent_34+muy_lane_vec_final1_speed_permanent_36)/2
    mux_lane_vec_final1_speed_permanent= (mux_lane_vec_final1_speed_permanent_34+mux_lane_vec_final1_speed_permanent_36)/2
    base_ptx_lane_vec_final1_speed_permanent= (base_ptx_lane_vec_final1_speed_permanent_34+base_ptx_lane_vec_final1_speed_permanent_36)/2
    base_pty_lane_vec_final1_speed_permanent= (base_pty_lane_vec_final1_speed_permanent_34+base_pty_lane_vec_final1_speed_permanent_36)/2


    #Speed on right track (group1)
    skip_speed_estimation=0
    speed_read_flag_1=0

    if skip_speed_estimation==0:

        speed_1,road_nomark_1,capture_frameindex_for_speed_1,frameindex_for_speed_1,white_mark_hit_1,speed_read_flag_1,count_scanned_lines_reverse_for_speed_1,count_scanned_lines_for_speed_1,offset_1,offset_at_end_of_mark_1,offset_at_middle_of_mark_1 = absolute_speed_estimation(muy_lane_vec_final1_speed_permanent,mux_lane_vec_final1_speed_permanent,base_ptx_lane_vec_final1_speed_permanent,base_pty_lane_vec_final1_speed_permanent,h1,capture_frameindex_for_speed_1,frameindex_for_speed_previous_1,frameindex_for_speed_1,image_number,white_mark_hit_1,count_scanned_lines_reverse_for_speed_previous_1,count_scanned_lines_reverse_for_speed_1,count_scanned_lines_for_speed_previous_1,count_scanned_lines_for_speed_1,offset_adjustment_1,range_adjustment_left_1,range_adjustment_right_1,img6,img2)


        #Update Speed reading
        if speed_read_flag_1==1:
            speed_official=speed_1
            first_reading_available_flag=1

            #Lane information extraction
            Lintersection=(0.7*h1-base_pty_lane_vec_final1_speed_permanent)/muy_lane_vec_final1_speed_permanent
            x2_lane=base_ptx_lane_vec_final1_speed_permanent+Lintersection*mux_lane_vec_final1_speed_permanent+offset_adjustment_1
            pt1_x_1=x2_lane+offset_1
            pt1_y_1=0.7*h1

            Lintersection=(0.7*h1-(count_scanned_lines_for_speed_1-1)-base_pty_lane_vec_final1_speed_permanent)/muy_lane_vec_final1_speed_permanent
            x2_lane_scan=base_ptx_lane_vec_final1_speed_permanent+Lintersection*mux_lane_vec_final1_speed_permanent+offset_adjustment_1
            pt2_x_1=x2_lane_scan+offset_at_end_of_mark_1
            pt2_y_1=0.7*h1-(count_scanned_lines_for_speed_1-1)

            L_mark=((pt2_x_1-pt1_x_1)**2+(pt2_y_1-pt1_y_1)**2)**0.5
            mux_lane_1=(pt2_x_1-pt1_x_1)/L_mark
            muy_lane_1=(pt2_y_1-pt1_y_1)/L_mark

            if offset_at_middle_of_mark_1!=-1000:
                Lintersection=(0.7*h1-(20-1)-base_pty_lane_vec_final1_speed_permanent)/muy_lane_vec_final1_speed_permanent
                x2_lane_scan=base_ptx_lane_vec_final1_speed_permanent+Lintersection*mux_lane_vec_final1_speed_permanent+offset_adjustment_1
                pt2b_x_1=x2_lane_scan+offset_at_middle_of_mark_1
                pt2b_y_1=0.7*h1-(20-1)

                L_markb=((pt2_x_1-pt2b_x_1)**2+(pt2_y_1-pt2b_y_1)**2)**0.5
                mux_laneb_1=(pt2_x_1-pt2b_x_1)/L_markb
                muy_laneb_1=(pt2_y_1-pt2b_y_1)/L_markb

                pt2e_x_2=pt1_x_1+300*((mux_lane_1+mux_laneb_1)/2)
                pt2e_y_2=pt1_y_1+300*((muy_lane_1+muy_laneb_1)/2)

                pt2f_x_2=pt1_x_1-100*((mux_lane_1+mux_laneb_1)/2)
                pt2f_y_2=pt1_y_1-100*((muy_lane_1+muy_laneb_1)/2)

            else:
                pt2e_x_2=pt1_x_1+300*mux_lane_1
                pt2e_y_2=pt1_y_1+300*muy_lane_1

                pt2f_x_2=pt1_x_1-100*mux_lane_1
                pt2f_y_2=pt1_y_1-100*muy_lane_1

            Right_lane_available_display=1


        if road_nomark_1==1 and white_mark_hit_1==1:
            count_road_nomark_1=count_road_nomark_1+1

        # Detecting ending of white road mark (the marker is over the pavement)
        if count_road_nomark_1==5:
            white_mark_hit_1=0
            count_road_nomark_1=0
            capture_frameindex_for_speed_1=0
            frameindex_for_speed_previous_1=frameindex_for_speed_1
            count_scanned_lines_reverse_for_speed_previous_1=count_scanned_lines_reverse_for_speed_1
            count_scanned_lines_for_speed_previous_1=count_scanned_lines_for_speed_1

    if speed_read_flag==1:
        print("offset: ",offset)
        print("count_scanned_lines_reverse_for_speed+count_scanned_lines_for_speed: ",count_scanned_lines_reverse_for_speed+count_scanned_lines_for_speed)
        #input("offset")

        if count_scanned_lines_reverse_for_speed+count_scanned_lines_for_speed<60 and count_scanned_lines_reverse_for_speed+count_scanned_lines_for_speed>=51 and exclude==0:
            if abs(offset)<70:
                count_marks_detected_for_adjustment=count_marks_detected_for_adjustment+1
                offset_adjustment_acc=offset_adjustment_acc+offset
                print("offset_considered:",offset)
                #input("conidered")
        else:
            if count_scanned_lines_reverse_for_speed+count_scanned_lines_for_speed<50 and count_scanned_lines_reverse_for_speed+count_scanned_lines_for_speed>=40 and exclude_b==0:
              if abs(offset)<100:
                count_marks_detected_for_adjustment_b=count_marks_detected_for_adjustment_b+1
                offset_adjustment_acc_b=offset_adjustment_acc_b+offset
                print("offset_considered:",offset)
                #input("conidered_b")
            else:
                if count_scanned_lines_reverse_for_speed+count_scanned_lines_for_speed<=95 and count_scanned_lines_reverse_for_speed+count_scanned_lines_for_speed>=90 and exclude_c==0:
                    if abs(offset)<100:
                        count_marks_detected_for_adjustment_c=count_marks_detected_for_adjustment_c+1
                        offset_adjustment_acc_c=offset_adjustment_acc_c+offset
                        print("offset_considered:",offset)
                        #input("conidered_c")


        if count_marks_detected_for_adjustment==2:
            offset_adjustment=offset_adjustment+0.6*(offset_adjustment_acc/count_marks_detected_for_adjustment) #moving conservatively
            count_marks_detected_for_adjustment=0
            offset_adjustment_acc=0
            count_adjustments=count_adjustments+1
            print("offset_adjustment: ",offset_adjustment)
            #input("adjustment")

        if count_marks_detected_for_adjustment_b==2:
            offset_adjustment=offset_adjustment+0.6*(offset_adjustment_acc_b/count_marks_detected_for_adjustment_b) #moving conservatively
            count_marks_detected_for_adjustment_b=0
            offset_adjustment_acc_b=0
            count_adjustments_b=count_adjustments_b+1
            print("offset_adjustment: ",offset_adjustment)
            #input("adjustment_b")

        if count_marks_detected_for_adjustment_c==2:
            offset_adjustment=offset_adjustment+0.6*(offset_adjustment_acc_c/count_marks_detected_for_adjustment_c) #moving conservatively
            count_marks_detected_for_adjustment_c=0
            offset_adjustment_acc_c=0
            count_adjustments_c=count_adjustments_c+1
            print("offset_adjustment: ",offset_adjustment)
            #input("adjustment_c")

        if count_adjustments==4:
            exclude_b=1
            exclude_c=1
            #input("exclude_b and c")
        if count_adjustments_b==4:
            exclude=1
            exclude_c=1
            #input("exclude and c")
        if count_adjustments_c==4:
            exclude=1
            exclude_b=1
            #input("exclude and b")

        if count_adjustments==4:
            range_adjustment_left=60 #decrease left range by 40
            #input("range adjusted")

        if count_adjustments_b==4:
            range_adjustment_left=60 #decrease left range by 40
            #input("range_b adjusted")

        if count_adjustments_c==4:
            range_adjustment_left=60 #decrease left range by 40
            #input("range_c adjusted")

    if speed_read_flag_1==1:
        print("offset_1: ",offset_1)
        print("count_scanned_lines_reverse_for_speed+count_scanned_lines_for_speed: ",count_scanned_lines_reverse_for_speed_1+count_scanned_lines_for_speed_1)
        #input("offset")

        if count_scanned_lines_reverse_for_speed_1+count_scanned_lines_for_speed_1<60 and count_scanned_lines_reverse_for_speed_1+count_scanned_lines_for_speed_1>=51 and exclude_1==0:
            if abs(offset_1)<70:
                count_marks_detected_for_adjustment_1=count_marks_detected_for_adjustment_1+1
                offset_adjustment_acc_1=offset_adjustment_acc_1+offset_1
                print("offset_considered_1:",offset_1)
                #input("conidered")
        else:
            if count_scanned_lines_reverse_for_speed_1+count_scanned_lines_for_speed_1<50 and count_scanned_lines_reverse_for_speed_1+count_scanned_lines_for_speed_1>=40 and exclude_b_1==0:
              if abs(offset_1)<100:
                count_marks_detected_for_adjustment_b_1=count_marks_detected_for_adjustment_b_1+1
                offset_adjustment_acc_b_1=offset_adjustment_acc_b_1+offset_1
                print("offset_considered_1:",offset_1)
                #input("conidered_b")
            else:
                if count_scanned_lines_reverse_for_speed_1+count_scanned_lines_for_speed_1<=95 and count_scanned_lines_reverse_for_speed_1+count_scanned_lines_for_speed_1>=90 and exclude_c_1==0:
                    if abs(offset_1)<100:
                        count_marks_detected_for_adjustment_c_1=count_marks_detected_for_adjustment_c_1+1
                        offset_adjustment_acc_c_1=offset_adjustment_acc_c_1+offset_1
                        print("offset_considered_1:",offset_1)
                        #input("conidered_c")

        if count_marks_detected_for_adjustment_1==2:
            offset_adjustment_1=offset_adjustment_1+0.6*(offset_adjustment_acc_1/count_marks_detected_for_adjustment_1) #moving conservatively
            count_marks_detected_for_adjustment_1=0
            offset_adjustment_acc_1=0
            count_adjustments_1=count_adjustments_1+1
            print("offset_adjustment_1: ",offset_adjustment_1)
            #input("adjustment")

        if count_marks_detected_for_adjustment_b_1==2:
            offset_adjustment_1=offset_adjustment_1+0.6*(offset_adjustment_acc_b_1/count_marks_detected_for_adjustment_b_1) #moving conservatively
            count_marks_detected_for_adjustment_b_1=0
            offset_adjustment_acc_b_1=0
            count_adjustments_b_1=count_adjustments_b_1+1
            print("offset_adjustment_1: ",offset_adjustment_1)
            #input("adjustment_b")

        if count_marks_detected_for_adjustment_c_1==2:
            offset_adjustment_1=offset_adjustment_1+0.6*(offset_adjustment_acc_c_1/count_marks_detected_for_adjustment_c_1) #moving conservatively
            count_marks_detected_for_adjustment_c_1=0
            offset_adjustment_acc_c_1=0
            count_adjustments_c_1=count_adjustments_c_1+1
            print("offset_adjustment_1: ",offset_adjustment_1)
            #input("adjustment_c")

        if count_adjustments_1==4:
            exclude_b_1=1
            exclude_c_1=1
            #input("exclude_b_1 and c_1")
        if count_adjustments_b_1==4:
            exclude_1=1
            exclude_c_1=1
            #input("exclude_1 and c_1")
        if count_adjustments_c_1==4:
            exclude_1=1
            exclude_b_1=1
            #input("exclude and b")

        if count_adjustments_1==4:
            range_adjustment_right_1=60 #decrease left range by 40
            #input("range adjusted_1")

        if count_adjustments_b_1==4:
            range_adjustment_right_1=60 #decrease left range by 40
            #input("range_b adjusted_1")

        if count_adjustments_c_1==4:
            range_adjustment_right_1=60 #decrease left range by 40
            #input("range_c adjusted_1")

    ####### LONG TERM AVERAGE FOR LANES ######

    if Left_lane_available_display==1 and speed_read_flag==1:

        mux_lane_vec_average[count_lanes_average_vec]=(mux_lane+mux_laneb)/2
        muy_lane_vec_average[count_lanes_average_vec]=(muy_lane+muy_laneb)/2
        base_ptx_lane_vec_average[count_lanes_average_vec]=pt1_x
        base_pty_lane_vec_average[count_lanes_average_vec]=pt1_y

        count_lanes_average_vec=count_lanes_average_vec+1


    if count_lanes_average_vec>=6:
        mux_lane_acc=0
        muy_lane_acc=0
        base_ptx_acc=0
        base_pty_acc=0
        #for k8 in range(0,6):
        for k8 in range(0,6):
            mux_lane_acc=mux_lane_acc+mux_lane_vec_average[count_lanes_average_vec-1-k8]
            muy_lane_acc=muy_lane_acc+muy_lane_vec_average[count_lanes_average_vec-1-k8]
            base_ptx_acc=base_ptx_acc+base_ptx_lane_vec_average[count_lanes_average_vec-1-k8]
            base_pty_acc=base_pty_acc+base_pty_lane_vec_average[count_lanes_average_vec-1-k8]
        mux_lane_ave=mux_lane_acc/6
        muy_lane_ave=muy_lane_acc/6
        base_ptx_ave=base_ptx_acc/6
        base_pty_ave=base_pty_acc/6

        pt2e_x=base_ptx_ave+450*mux_lane_ave
        pt2e_y=base_pty_ave+450*muy_lane_ave

        pt2f_x=base_ptx_ave-180*mux_lane_ave
        pt2f_y=base_pty_ave-180*muy_lane_ave




    if Right_lane_available_display==1 and speed_read_flag_1==1:

        mux_lane_vec_average2[count_lanes_average_vec2]=(mux_lane_1+mux_laneb_1)/2
        muy_lane_vec_average2[count_lanes_average_vec2]=(muy_lane_1+muy_laneb_1)/2
        base_ptx_lane_vec_average2[count_lanes_average_vec2]=pt1_x_1
        base_pty_lane_vec_average2[count_lanes_average_vec2]=pt1_y_1

        count_lanes_average_vec2=count_lanes_average_vec2+1


    if count_lanes_average_vec2>=6:
        mux_lane_acc=0
        muy_lane_acc=0
        base_ptx_acc=0
        base_pty_acc=0
        #for k8 in range(0,6):
        for k8 in range(0,6):
            mux_lane_acc=mux_lane_acc+mux_lane_vec_average2[count_lanes_average_vec2-1-k8]
            muy_lane_acc=muy_lane_acc+muy_lane_vec_average2[count_lanes_average_vec2-1-k8]
            base_ptx_acc=base_ptx_acc+base_ptx_lane_vec_average2[count_lanes_average_vec2-1-k8]
            base_pty_acc=base_pty_acc+base_pty_lane_vec_average2[count_lanes_average_vec2-1-k8]
        mux_lane_ave_1=mux_lane_acc/6
        muy_lane_ave_1=muy_lane_acc/6
        base_ptx_ave_1=base_ptx_acc/6
        base_pty_ave_1=base_pty_acc/6

        pt2e_x_1=base_ptx_ave_1+350*mux_lane_ave_1
        pt2e_y_1=base_pty_ave_1+350*muy_lane_ave_1

        pt2f_x_1=base_ptx_ave_1-160*mux_lane_ave_1
        pt2f_y_1=base_pty_ave_1-160*muy_lane_ave_1


    ############## DISPLAY #################

    #if Left_lane_available_display==1:
    #    cv2.line(img6, (int(pt1_x), int(pt1_y)), (int(pt2e_x), int(pt2e_y)), (0,255,0), 1, cv2.LINE_AA)
    #    cv2.line(img6, (int(pt1_x), int(pt1_y)), (int(pt2f_x), int(pt2f_y)), (0,255,0), 1, cv2.LINE_AA)

    #if Right_lane_available_display==1:
    #    cv2.line(img6, (int(pt1_x_1), int(pt1_y_1)), (int(pt2e_x_2), int(pt2e_y_2)), (0,0,255), 1, cv2.LINE_AA)
    #    cv2.line(img6, (int(pt1_x_1), int(pt1_y_1)), (int(pt2f_x_2), int(pt2f_y_2)), (0,0,255), 1, cv2.LINE_AA)
    #   cv2.line(img6, (int(pt1_x_1-80), int(pt1_y_1)), (int(pt1_x_1+80), int(pt1_y_1)), (0,255,0), 1, cv2.LINE_AA)

    if count_lanes_average_vec>=6:
        cv2.line(img6, (int(base_ptx_ave), int(base_pty_ave)), (int(pt2e_x), int(pt2e_y)), (0,255,0), 1, cv2.LINE_AA)
        cv2.line(img6, (int(base_ptx_ave), int(base_pty_ave)), (int(pt2f_x), int(pt2f_y)), (0,255,0), 1, cv2.LINE_AA)

    if count_lanes_average_vec2>=6:
        cv2.line(img6, (int(base_ptx_ave_1), int(base_pty_ave_1)), (int(pt2e_x_1), int(pt2e_y_1)), (0,255,0), 1, cv2.LINE_AA)
        cv2.line(img6, (int(base_ptx_ave_1), int(base_pty_ave_1)), (int(pt2f_x_1), int(pt2f_y_1)), (0,255,0), 1, cv2.LINE_AA)
        #cv2.line(img6, (int(base_ptx_ave_1-80), int(base_pty_ave_1)), (int(base_ptx_ave_1+80), int(base_pty_ave_1)), (0,255,0), 1, cv2.LINE_AA)

    #resizing image for displaying purposes
    img7=img6
    dim = (3840,2880)
    resized = cv2.resize(img7, dim, interpolation=cv2.INTER_CUBIC)

    if first_reading_available_flag!=0:
        speed_text='Speed: '+str(int(speed_official))+' miles/hr'
        cv2.putText(resized,speed_text, (250,150), cv2.FONT_HERSHEY_SIMPLEX, 4, (255,255,255),2,cv2.LINE_AA)
    print("TIME: ",image_number/30)
    cv2.namedWindow('Frame4',cv2.WINDOW_NORMAL)
    cv2.imshow('Frame4',resized )
    cv2.waitKey(1)
